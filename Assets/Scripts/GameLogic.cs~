using UnityEngine;
using System.Collections;
using UnityEngine.SceneManagement;

public class GameLogic : MonoBehaviour {

    private char[] state;
    private int stateCounter;
    private Ray ray;
    private RaycastHit hit;

    public GameObject redCircle;
    public GameObject blueCircle;
    public GameObject greenCircle;
    public GameObject yellowCircle;
    public Material[] material;
    public float waitTime;
    private int phase;

    public bool touchOn;
    private bool phase_timer1;
    private bool phase_timer2;
    private bool phase_timer3;
    private bool phase_timer4;

    // Use this for initialization
    void Start () {
        state = new char[4];
        stateCounter = 0;
        redCircle.GetComponent<Renderer>().sharedMaterial = material[0];
        blueCircle.GetComponent<Renderer>().sharedMaterial = material[2];
        greenCircle.GetComponent<Renderer>().sharedMaterial = material[4];
        yellowCircle.GetComponent<Renderer>().sharedMaterial = material[6];
        phase = 1;
        touchOn = false;
        phase_timer1 = true;
        phase_timer2 = false;
        phase_timer3 = false;
        phase_timer4 = false;
    }
	
	// Update is called once per frame
	void Update () {
        if (stateCounter == 4)
        {
            ++phase;
            stateCounter = 0;
            touchOn = false;

        }
        if (phase == 5)
        {
            SceneManager.LoadScene("Phase 4");
        }
        if (Input.touchCount == 1 && touchOn == true)
        {
            ray = Camera.main.ScreenPointToRay(Input.GetTouch(0).position);
            switch (Input.GetTouch(0).phase)
            {
                case (TouchPhase.Began):
                case (TouchPhase.Moved):
                case (TouchPhase.Stationary):
                    if (Physics.Raycast(ray, out hit, Mathf.Infinity) && hit.transform.tag == redCircle.tag)
                    {
                        hit.collider.gameObject.GetComponent<Renderer>().sharedMaterial = material[1];

                    }
                    else if (Physics.Raycast(ray, out hit, Mathf.Infinity) && hit.transform.tag == blueCircle.tag)
                    {
                        hit.collider.gameObject.GetComponent<Renderer>().sharedMaterial = material[3];
                    }
                    else if (Physics.Raycast(ray, out hit, Mathf.Infinity) && hit.transform.tag == greenCircle.tag)
                    {
                        hit.collider.gameObject.GetComponent<Renderer>().sharedMaterial = material[5];
                    }
                    else if (Physics.Raycast(ray, out hit, Mathf.Infinity) && hit.transform.tag == yellowCircle.tag)
                    {
                        hit.collider.gameObject.GetComponent<Renderer>().sharedMaterial = material[7];
                    }
                    break;
                case (TouchPhase.Ended):
                    if (Physics.Raycast(ray, out hit, Mathf.Infinity) && hit.transform.tag == redCircle.tag)
                    {
                        hit.collider.gameObject.GetComponent<Renderer>().sharedMaterial = material[0];
                        if (state[stateCounter] != 'R')
                        {
                            stateCounter = 0;
                        }
                        else
                        {
                            ++stateCounter;
                        }
                    }
                    else if (Physics.Raycast(ray, out hit, Mathf.Infinity) && hit.transform.tag == blueCircle.tag)
                    {
                        hit.collider.gameObject.GetComponent<Renderer>().sharedMaterial = material[2];
                        if (state[stateCounter] != 'B')
                        {
                            stateCounter = 0;
                        }
                        else
                        {
                            ++stateCounter;
                        }
                    }
                    else if (Physics.Raycast(ray, out hit, Mathf.Infinity) && hit.transform.tag == greenCircle.tag)
                    {
                        hit.collider.gameObject.GetComponent<Renderer>().sharedMaterial = material[4];
                        if (state[stateCounter] != 'G')
                        {
                            stateCounter = 0;
                        }
                        else
                        {
                            ++stateCounter;
                        }
                    }
                    else if (Physics.Raycast(ray, out hit, Mathf.Infinity) && hit.transform.tag == yellowCircle.tag)
                    {
                        hit.collider.gameObject.GetComponent<Renderer>().sharedMaterial = material[6];
                        if (state[stateCounter] != 'Y')
                        {
                            stateCounter = 0;
                        }
                        else
                        {
                            ++stateCounter;
                        }
                    }
                    break;
            }
        }
        if (touchOn == false)
        {
            switch (phase)
            {
                case 1:
                    if(phase_timer1 == true)
                    {
                        state = new char[] {'R', 'B', 'G', 'Y' };
                        StartCoroutine(phase1_logic());
                    }
                    break;
                case 2:
                    if(phase_timer2 == true)
                    {
                        state = new char[] { 'Y', 'G', 'R', 'B' };
                        StartCoroutine(phase2_logic());
                    }
                    break;
                case 3:
                    if(phase_timer3 == true)
                    {
                        state = new char[] { 'R', 'Y', 'B', 'G' };
                        StartCoroutine(phase3_logic());
                    }
                    break;
                case 4:
                    if(phase_timer4 == true)
                    {
                        state = new char[] { 'Y', 'B', 'G', 'R' };
                        StartCoroutine(phase4_logic());
                    }
                    break;
            }
        }
	}

    IEnumerator phase1_logic()
    {
        phase_timer1 = false;

        redCircle.GetComponent<Renderer>().sharedMaterial = material[1];

        yield return new WaitForSeconds(waitTime);

        redCircle.GetComponent<Renderer>().sharedMaterial = material[0];
        blueCircle.GetComponent<Renderer>().sharedMaterial = material[3];

        yield return new WaitForSeconds(waitTime);

        blueCircle.GetComponent<Renderer>().sharedMaterial = material[2];
        greenCircle.GetComponent<Renderer>().sharedMaterial = material[5];

        yield return new WaitForSeconds(waitTime);

        greenCircle.GetComponent<Renderer>().sharedMaterial = material[4];
        yellowCircle.GetComponent<Renderer>().sharedMaterial = material[7];

        yield return new WaitForSeconds(waitTime);

        yellowCircle.GetComponent<Renderer>().sharedMaterial = material[6];

        phase_timer2 = true;
        touchOn = true;
    }

    IEnumerator phase2_logic()
    {
        phase_timer2 = false;

        yellowCircle.GetComponent<Renderer>().sharedMaterial = material[7];

        yield return new WaitForSeconds(waitTime);

        yellowCircle.GetComponent<Renderer>().sharedMaterial = material[6];
        greenCircle.GetComponent<Renderer>().sharedMaterial = material[5];

        yield return new WaitForSeconds(waitTime);

        greenCircle.GetComponent<Renderer>().sharedMaterial = material[4];
        redCircle.GetComponent<Renderer>().sharedMaterial = material[1];

        yield return new WaitForSeconds(waitTime);

        redCircle.GetComponent<Renderer>().sharedMaterial = material[0];
        blueCircle.GetComponent<Renderer>().sharedMaterial = material[3];

        yield return new WaitForSeconds(waitTime);

        blueCircle.GetComponent<Renderer>().sharedMaterial = material[2];

        phase_timer3 = true;
        touchOn = true;
    }

    IEnumerator phase3_logic()
    {
        phase_timer3 = false;

        redCircle.GetComponent<Renderer>().sharedMaterial = material[1];

        yield return new WaitForSeconds(waitTime);

        redCircle.GetComponent<Renderer>().sharedMaterial = material[0];
        yellowCircle.GetComponent<Renderer>().sharedMaterial = material[7];

        yield return new WaitForSeconds(waitTime);

        yellowCircle.GetComponent<Renderer>().sharedMaterial = material[6];
        blueCircle.GetComponent<Renderer>().sharedMaterial = material[3];

        yield return new WaitForSeconds(waitTime);

        blueCircle.GetComponent<Renderer>().sharedMaterial = material[2];
        greenCircle.GetComponent<Renderer>().sharedMaterial = material[5];

        yield return new WaitForSeconds(waitTime);

        greenCircle.GetComponent<Renderer>().sharedMaterial = material[4];

        phase_timer4 = true;
        touchOn = true;
    }

    IEnumerator phase4_logic()
    {
        phase_timer4 = false;

        yellowCircle.GetComponent<Renderer>().sharedMaterial = material[7];

        yield return new WaitForSeconds(waitTime);

        yellowCircle.GetComponent<Renderer>().sharedMaterial = material[6];
        blueCircle.GetComponent<Renderer>().sharedMaterial = material[3];

        yield return new WaitForSeconds(waitTime);

        blueCircle.GetComponent<Renderer>().sharedMaterial = material[2];
        greenCircle.GetComponent<Renderer>().sharedMaterial = material[5];

        yield return new WaitForSeconds(waitTime);

        greenCircle.GetComponent<Renderer>().sharedMaterial = material[4];
        redCircle.GetComponent<Renderer>().sharedMaterial = material[1];

        yield return new WaitForSeconds(waitTime);

        redCircle.GetComponent<Renderer>().sharedMaterial = material[0];

        touchOn = true;
    }
}
